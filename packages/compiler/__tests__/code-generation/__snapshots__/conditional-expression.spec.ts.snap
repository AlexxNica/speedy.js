// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ConditionalExpression boolean-condition 1`] = `
"; ModuleID = 'conditional-expression/boolean-condition.ts'
source_filename = \\"conditional-expression/boolean-condition.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_booleanConditionalExpression(i1 %condition) {
entry:
  %condition.addr = alloca i1, align 1
  store i1 %condition, i1* %condition.addr, align 1
  %condition.addr1 = load i1, i1* %condition.addr, align 1
  %cond = select i1 %condition.addr1, i1 true, i1 false
  %condition.addr2 = load i1, i1* %condition.addr, align 1
  %cond3 = select i1 %condition.addr2, i32 1, i32 2
  %condition.addr4 = load i1, i1* %condition.addr, align 1
  %cond5 = select i1 %condition.addr4, double 1.000000e+00, double 2.000000e+00
  ret void
}
"
`;

exports[`ConditionalExpression int-condition 1`] = `
"; ModuleID = 'conditional-expression/int-condition.ts'
source_filename = \\"conditional-expression/int-condition.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_intConditionalExpression(i32 %condition) {
entry:
  %condition.addr = alloca i32, align 4
  store i32 %condition, i32* %condition.addr, align 4
  %condition.addr1 = load i32, i32* %condition.addr, align 4
  %condition.addr1AsBool = icmp ne i32 %condition.addr1, 0
  %cond = select i1 %condition.addr1AsBool, i1 true, i1 false
  %condition.addr2 = load i32, i32* %condition.addr, align 4
  %condition.addr2AsBool = icmp ne i32 %condition.addr2, 0
  %cond3 = select i1 %condition.addr2AsBool, i32 1, i32 2
  %condition.addr4 = load i32, i32* %condition.addr, align 4
  %condition.addr4AsBool = icmp ne i32 %condition.addr4, 0
  %cond5 = select i1 %condition.addr4AsBool, double 1.000000e+00, double 2.000000e+00
  ret void
}
"
`;

exports[`ConditionalExpression number-condition 1`] = `
"; ModuleID = 'conditional-expression/number-condition.ts'
source_filename = \\"conditional-expression/number-condition.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_intConditionalExpression(double %condition) {
entry:
  %condition.addr = alloca double, align 8
  store double %condition, double* %condition.addr, align 8
  %condition.addr1 = load double, double* %condition.addr, align 8
  %condition.addr1AsBool = fcmp one double %condition.addr1, 0.000000e+00
  %cond = select i1 %condition.addr1AsBool, i1 true, i1 false
  %condition.addr2 = load double, double* %condition.addr, align 8
  %condition.addr2AsBool = fcmp one double %condition.addr2, 0.000000e+00
  %cond3 = select i1 %condition.addr2AsBool, i32 1, i32 2
  %condition.addr4 = load double, double* %condition.addr, align 8
  %condition.addr4AsBool = fcmp one double %condition.addr4, 0.000000e+00
  %cond5 = select i1 %condition.addr4AsBool, double 1.000000e+00, double 2.000000e+00
  ret void
}
"
`;
