// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`BinaryExpression ampersand 1`] = `
"; ModuleID = 'binary-expression/ampersand.ts'
source_filename = \\"binary-expression/ampersand.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_ampersand() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %and = and i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %and3 = and i32 %intValue2, 2
  store i32 %and3, i32* %intValue, align 4
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression ampersandAmpersand 1`] = `
"; ModuleID = 'binary-expression/ampersandAmpersand.ts'
source_filename = \\"binary-expression/ampersandAmpersand.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_ampersandAmpersand() {
entry:
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  br i1 true, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  br label %land.end

land.end:                                         ; preds = %land.lhs.true, %entry
  %land = phi i1 [ true, %entry ], [ true, %land.lhs.true ]
  br i1 %land, label %land.lhs.true1, label %land.end2

land.lhs.true1:                                   ; preds = %land.end
  br label %land.end2

land.end2:                                        ; preds = %land.lhs.true1, %land.end
  %land3 = phi i1 [ %land, %land.end ], [ false, %land.lhs.true1 ]
  br i1 true, label %land.lhs.true4, label %land.end5

land.lhs.true4:                                   ; preds = %land.end2
  br label %land.end5

land.end5:                                        ; preds = %land.lhs.true4, %land.end2
  %land6 = phi i32 [ 10, %land.end2 ], [ 3, %land.lhs.true4 ]
  %land6AsBool = icmp ne i32 %land6, 0
  br i1 %land6AsBool, label %land.lhs.true7, label %land.end8

land.lhs.true7:                                   ; preds = %land.end5
  br label %land.end8

land.end8:                                        ; preds = %land.lhs.true7, %land.end5
  %land9 = phi i32 [ %land6, %land.end5 ], [ 1, %land.lhs.true7 ]
  ret void
}
"
`;

exports[`BinaryExpression asterisk 1`] = `
"; ModuleID = 'binary-expression/asterisk.ts'
source_filename = \\"binary-expression/asterisk.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_asterisk() {
entry:
  %doubleProduct = alloca double, align 8
  %intProduct = alloca i32, align 4
  store i32 12, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %mul = mul i32 %intProduct1, 2
  store i32 %mul, i32* %intProduct, align 4
  store double 1.200000e+01, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %mul3 = fmul double %doubleProduct2, 1.500000e+00
  store double %mul3, double* %doubleProduct, align 8
  ret void
}
"
`;

exports[`BinaryExpression asteriskAsterisk 1`] = `
"; ModuleID = 'binary-expression/asteriskAsterisk.ts'
source_filename = \\"binary-expression/asteriskAsterisk.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_asteriskAsterisk() {
entry:
  %doubleProduct = alloca double, align 8
  %intProduct = alloca double, align 8
  %powReturnValue = call double @llvm.pow.f64(double 3.000000e+00, double 4.000000e+00)
  store double %powReturnValue, double* %intProduct, align 8
  %intProduct1 = load double, double* %intProduct, align 8
  %powReturnValue2 = call double @llvm.pow.f64(double %intProduct1, double 2.000000e+00)
  store double %powReturnValue2, double* %intProduct, align 8
  %powReturnValue3 = call double @llvm.pow.f64(double 3.000000e+00, double 4.000000e+00)
  store double %powReturnValue3, double* %doubleProduct, align 8
  %doubleProduct4 = load double, double* %doubleProduct, align 8
  %powReturnValue5 = call double @llvm.pow.f64(double %doubleProduct4, double 1.500000e+00)
  store double %powReturnValue5, double* %doubleProduct, align 8
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.pow.f64(double, double) #0

attributes #0 = { nounwind readnone speculatable }
"
`;

exports[`BinaryExpression bar 1`] = `
"; ModuleID = 'binary-expression/bar.ts'
source_filename = \\"binary-expression/bar.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_bar() {
entry:
  %intToInt = alloca i32, align 4
  %intValue = alloca i32, align 4
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %or = or i32 %six1, 8
  store i32 %or, i32* %six, align 4
  %AsInt32 = call i32 @toInt32d(double 3.560000e+00)
  store i32 %AsInt32, i32* %intValue, align 4
  store i32 3, i32* %intToInt, align 4
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression barBar 1`] = `
"; ModuleID = 'binary-expression/barBar.ts'
source_filename = \\"binary-expression/barBar.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_barBar() {
entry:
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %six1AsBool = icmp ne i32 %six1, 0
  %not = xor i1 %six1AsBool, true
  %not2 = xor i1 %not, true
  br i1 %not2, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  br label %lor.end

lor.end:                                          ; preds = %lor.lhs.false, %entry
  %lor = phi i1 [ %not2, %entry ], [ true, %lor.lhs.false ]
  br i1 %lor, label %lor.end4, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.end
  br label %lor.end4

lor.end4:                                         ; preds = %lor.lhs.false3, %lor.end
  %lor5 = phi i1 [ %lor, %lor.end ], [ false, %lor.lhs.false3 ]
  br i1 true, label %lor.end7, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.end4
  br label %lor.end7

lor.end7:                                         ; preds = %lor.lhs.false6, %lor.end4
  %lor8 = phi i32 [ 10, %lor.end4 ], [ 3, %lor.lhs.false6 ]
  %lor8AsBool = icmp ne i32 %lor8, 0
  br i1 %lor8AsBool, label %lor.end10, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.end7
  br label %lor.end10

lor.end10:                                        ; preds = %lor.lhs.false9, %lor.end7
  %lor11 = phi i32 [ %lor8, %lor.end7 ], [ 1, %lor.lhs.false9 ]
  ret void
}
"
`;

exports[`BinaryExpression caret 1`] = `
"; ModuleID = 'binary-expression/caret.ts'
source_filename = \\"binary-expression/caret.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_caret() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %xor = xor i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %xor3 = xor i32 %intValue2, 2
  store i32 %xor3, i32* %intValue, align 4
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression equalsEqualsEquals 1`] = `
"; ModuleID = 'binary-expression/equalsEqualsEquals.ts'
source_filename = \\"binary-expression/equalsEqualsEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_equalsEqualsEqualsToken() {
entry:
  %trueValue = alloca i1, align 1
  %threePointFour = alloca double, align 8
  %four = alloca i32, align 4
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %cmpEQ = icmp eq i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %cmpEQ3 = fcmp oeq double %threePointFour2, 3.400000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %cmpEQ5 = icmp eq i1 %trueValue4, true
  ret void
}
"
`;

exports[`BinaryExpression exclamationEqualsEquals 1`] = `
"; ModuleID = 'binary-expression/exclamationEqualsEquals.ts'
source_filename = \\"binary-expression/exclamationEqualsEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_exclamationEqualsEqualsToken() {
entry:
  %trueValue = alloca i1, align 1
  %threePointFour = alloca double, align 8
  %four = alloca i32, align 4
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %cmpNE = icmp ne i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %cmpNE3 = fcmp one double %threePointFour2, 3.400000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %cmpNE5 = icmp ne i1 %trueValue4, true
  ret void
}
"
`;

exports[`BinaryExpression greaterThan 1`] = `
"; ModuleID = 'binary-expression/greaterThan.ts'
source_filename = \\"binary-expression/greaterThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThan() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpGT = icmp sgt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpGT3 = fcmp ogt double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpGT5 = icmp sgt i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression greaterThanEquals 1`] = `
"; ModuleID = 'binary-expression/greaterThanEquals.ts'
source_filename = \\"binary-expression/greaterThanEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanEquals() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpGE = icmp sge i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpGE3 = fcmp oge double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpGE5 = icmp sge i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression greaterThanGreaterThanGreaterThan 1`] = `
"; ModuleID = 'binary-expression/greaterThanGreaterThanGreaterThan.ts'
source_filename = \\"binary-expression/greaterThanGreaterThanGreaterThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanGreaterThanGreaterThan() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %lshr = lshr i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %lshr3 = lshr i32 %intValue2, 2
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression lessThan 1`] = `
"; ModuleID = 'binary-expression/lessThan.ts'
source_filename = \\"binary-expression/lessThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThan() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpLT = icmp slt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpLT3 = fcmp olt double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpLT5 = icmp slt i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression lessThanEquals 1`] = `
"; ModuleID = 'binary-expression/lessThanEquals.ts'
source_filename = \\"binary-expression/lessThanEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThanEquals() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpLE = icmp sle i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpLE3 = fcmp ole double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpLE5 = icmp sle i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression lessThanLessThan 1`] = `
"; ModuleID = 'binary-expression/lessThanLessThan.ts'
source_filename = \\"binary-expression/lessThanLessThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThanLessThan() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %shl = shl i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %shl3 = shl i32 %intValue2, 2
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression minus 1`] = `
"; ModuleID = 'binary-expression/minus.ts'
source_filename = \\"binary-expression/minus.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_minus() {
entry:
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %sub = sub i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %fsub = fsub double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %sub4 = sub i32 %two3, 2
  store i32 %sub4, i32* %two, align 4
  %twoDouble5 = load double, double* %twoDouble, align 8
  %fsub6 = fsub double %twoDouble5, 2.000000e+00
  store double %fsub6, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression percent 1`] = `
"; ModuleID = 'binary-expression/percent.ts'
source_filename = \\"binary-expression/percent.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_percent() {
entry:
  %sixDouble = alloca double, align 8
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  store double 6.000000e+00, double* %sixDouble, align 8
  %six1 = load i32, i32* %six, align 4
  %srem = srem i32 8, %six1
  %sixDouble2 = load double, double* %sixDouble, align 8
  %frem = frem double 8.000000e+00, %sixDouble2
  ret void
}
"
`;

exports[`BinaryExpression plus 1`] = `
"; ModuleID = 'binary-expression/plus.ts'
source_filename = \\"binary-expression/plus.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_plus() {
entry:
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %add = add i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %fadd = fadd double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %add4 = add i32 %two3, 2
  store i32 %add4, i32* %two, align 4
  %twoDouble5 = load double, double* %twoDouble, align 8
  %fadd6 = fadd double %twoDouble5, 2.000000e+00
  store double %fadd6, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression slash 1`] = `
"; ModuleID = 'binary-expression/slash.ts'
source_filename = \\"binary-expression/slash.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object

define void @_slash() {
entry:
  %doubleProduct = alloca double, align 8
  %intProduct = alloca i32, align 4
  store i32 1, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %sdiv = sdiv i32 %intProduct1, 2
  store i32 %sdiv, i32* %intProduct, align 4
  store double 0x3FF5555555555555, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %div = fdiv double %doubleProduct2, 1.500000e+00
  store double %div, double* %doubleProduct, align 8
  ret void
}
"
`;
