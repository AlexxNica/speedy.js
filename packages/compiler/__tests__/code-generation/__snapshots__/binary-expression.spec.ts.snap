// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`BinaryExpression ampersand 1`] = `
"; ModuleID = 'binary-expression/ampersand.ts'
source_filename = \\"binary-expression/ampersand.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_ampersand() {
entry:
  %numberValue = alloca double
  %intValue = alloca i32
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %and = and i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %and3 = and i32 %intValue2, 2
  store i32 %and3, i32* %intValue, align 4
  ret void
}

declare i32 @toInt32d(double)
"
`;

exports[`BinaryExpression ampersandAmpersand 1`] = `
"; ModuleID = 'binary-expression/ampersandAmpersand.ts'
source_filename = \\"binary-expression/ampersandAmpersand.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_ampersandAmpersand() {
entry:
  %andResult10 = alloca i32
  %andResult6 = alloca i32
  %andResult2 = alloca i1
  %andResult = alloca i1
  %six = alloca i32
  store i32 6, i32* %six, align 4
  store i1 true, i1* %andResult, align 1
  br i1 true, label %trueBranch, label %andSuccessor

trueBranch:                                       ; preds = %entry
  store i1 true, i1* %andResult, align 1
  br label %andSuccessor

andSuccessor:                                     ; preds = %trueBranch, %entry
  %andResult1 = load i1, i1* %andResult, align 1
  store i1 %andResult1, i1* %andResult2, align 1
  br i1 %andResult1, label %trueBranch3, label %andSuccessor4

trueBranch3:                                      ; preds = %andSuccessor
  store i1 false, i1* %andResult2, align 1
  br label %andSuccessor4

andSuccessor4:                                    ; preds = %trueBranch3, %andSuccessor
  %andResult5 = load i1, i1* %andResult2, align 1
  store i32 10, i32* %andResult6, align 4
  br i1 true, label %trueBranch7, label %andSuccessor8

trueBranch7:                                      ; preds = %andSuccessor4
  store i32 3, i32* %andResult6, align 4
  br label %andSuccessor8

andSuccessor8:                                    ; preds = %trueBranch7, %andSuccessor4
  %andResult9 = load i32, i32* %andResult6, align 4
  store i32 %andResult9, i32* %andResult10, align 4
  %andResult9AsBool = icmp ne i32 %andResult9, 0
  br i1 %andResult9AsBool, label %trueBranch11, label %andSuccessor12

trueBranch11:                                     ; preds = %andSuccessor8
  store i32 1, i32* %andResult10, align 4
  br label %andSuccessor12

andSuccessor12:                                   ; preds = %trueBranch11, %andSuccessor8
  %andResult13 = load i32, i32* %andResult10, align 4
  ret void
}
"
`;

exports[`BinaryExpression asterisk 1`] = `
"; ModuleID = 'binary-expression/asterisk.ts'
source_filename = \\"binary-expression/asterisk.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_asterisk() {
entry:
  %doubleProduct = alloca double
  %intProduct = alloca i32
  store i32 12, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %mul = mul i32 %intProduct1, 2
  store i32 %mul, i32* %intProduct, align 4
  store double 1.200000e+01, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %mul3 = fmul double %doubleProduct2, 1.500000e+00
  store double %mul3, double* %doubleProduct, align 8
  ret void
}
"
`;

exports[`BinaryExpression asteriskAsterisk 1`] = `
"; ModuleID = 'binary-expression/asteriskAsterisk.ts'
source_filename = \\"binary-expression/asteriskAsterisk.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_asteriskAsterisk() {
entry:
  %doubleProduct = alloca double
  %intProduct = alloca double
  %powReturnValue = call double @Math_powdd(double 3.000000e+00, double 4.000000e+00)
  store double %powReturnValue, double* %intProduct, align 8
  %intProduct1 = load double, double* %intProduct, align 8
  %powReturnValue2 = call double @Math_powdd(double %intProduct1, double 2.000000e+00)
  store double %powReturnValue2, double* %intProduct, align 8
  %powReturnValue3 = call double @Math_powdd(double 3.000000e+00, double 4.000000e+00)
  store double %powReturnValue3, double* %doubleProduct, align 8
  %doubleProduct4 = load double, double* %doubleProduct, align 8
  %powReturnValue5 = call double @Math_powdd(double %doubleProduct4, double 1.500000e+00)
  store double %powReturnValue5, double* %doubleProduct, align 8
  ret void
}

declare double @Math_powdd(double, double)
"
`;

exports[`BinaryExpression bar 1`] = `
"; ModuleID = 'binary-expression/bar.ts'
source_filename = \\"binary-expression/bar.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_bar() {
entry:
  %intToInt = alloca i32
  %intValue = alloca i32
  %six = alloca i32
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %or = or i32 %six1, 8
  store i32 %or, i32* %six, align 4
  %AsInt32 = call i32 @toInt32d(double 3.560000e+00)
  store i32 %AsInt32, i32* %intValue, align 4
  store i32 3, i32* %intToInt, align 4
  ret void
}

declare i32 @toInt32d(double)
"
`;

exports[`BinaryExpression barBar 1`] = `
"; ModuleID = 'binary-expression/barBar.ts'
source_filename = \\"binary-expression/barBar.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_barBar() {
entry:
  %orResult12 = alloca i32
  %orResult8 = alloca i32
  %orResult4 = alloca i1
  %orResult = alloca i1
  %six = alloca i32
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %six1AsBool = icmp ne i32 %six1, 0
  %not = xor i1 %six1AsBool, true
  %not2 = xor i1 %not, true
  store i1 %not2, i1* %orResult, align 1
  br i1 %not2, label %orSuccessor, label %orCase

orCase:                                           ; preds = %entry
  store i1 true, i1* %orResult, align 1
  br label %orSuccessor

orSuccessor:                                      ; preds = %orCase, %entry
  %orResult3 = load i1, i1* %orResult, align 1
  store i1 %orResult3, i1* %orResult4, align 1
  br i1 %orResult3, label %orSuccessor6, label %orCase5

orCase5:                                          ; preds = %orSuccessor
  store i1 false, i1* %orResult4, align 1
  br label %orSuccessor6

orSuccessor6:                                     ; preds = %orCase5, %orSuccessor
  %orResult7 = load i1, i1* %orResult4, align 1
  store i32 10, i32* %orResult8, align 4
  br i1 true, label %orSuccessor10, label %orCase9

orCase9:                                          ; preds = %orSuccessor6
  store i32 3, i32* %orResult8, align 4
  br label %orSuccessor10

orSuccessor10:                                    ; preds = %orCase9, %orSuccessor6
  %orResult11 = load i32, i32* %orResult8, align 4
  store i32 %orResult11, i32* %orResult12, align 4
  %orResult11AsBool = icmp ne i32 %orResult11, 0
  br i1 %orResult11AsBool, label %orSuccessor14, label %orCase13

orCase13:                                         ; preds = %orSuccessor10
  store i32 1, i32* %orResult12, align 4
  br label %orSuccessor14

orSuccessor14:                                    ; preds = %orCase13, %orSuccessor10
  %orResult15 = load i32, i32* %orResult12, align 4
  ret void
}
"
`;

exports[`BinaryExpression caret 1`] = `
"; ModuleID = 'binary-expression/caret.ts'
source_filename = \\"binary-expression/caret.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_caret() {
entry:
  %numberValue = alloca double
  %intValue = alloca i32
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %xor = xor i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %xor3 = xor i32 %intValue2, 2
  store i32 %xor3, i32* %intValue, align 4
  ret void
}

declare i32 @toInt32d(double)
"
`;

exports[`BinaryExpression equalsEqualsEquals 1`] = `
"; ModuleID = 'binary-expression/equalsEqualsEquals.ts'
source_filename = \\"binary-expression/equalsEqualsEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_equalsEqualsEqualsToken() {
entry:
  %trueValue = alloca i1
  %threePointFour = alloca double
  %four = alloca i32
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %cmpEQ = icmp eq i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %cmpEQ3 = fcmp oeq double %threePointFour2, 3.400000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %cmpEQ5 = icmp eq i1 %trueValue4, true
  ret void
}
"
`;

exports[`BinaryExpression exclamationEqualsEquals 1`] = `
"; ModuleID = 'binary-expression/exclamationEqualsEquals.ts'
source_filename = \\"binary-expression/exclamationEqualsEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_exclamationEqualsEqualsToken() {
entry:
  %trueValue = alloca i1
  %threePointFour = alloca double
  %four = alloca i32
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %cmpNE = icmp ne i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %cmpNE3 = fcmp one double %threePointFour2, 3.400000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %cmpNE5 = icmp ne i1 %trueValue4, true
  ret void
}
"
`;

exports[`BinaryExpression greaterThan 1`] = `
"; ModuleID = 'binary-expression/greaterThan.ts'
source_filename = \\"binary-expression/greaterThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_greaterThan() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpGT = icmp sgt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpGT3 = fcmp ogt double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpGT5 = icmp sgt i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression greaterThanEquals 1`] = `
"; ModuleID = 'binary-expression/greaterThanEquals.ts'
source_filename = \\"binary-expression/greaterThanEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_greaterThanEquals() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpGE = icmp sge i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpGE3 = fcmp oge double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpGE5 = icmp sge i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression greaterThanGreaterThanGreaterThan 1`] = `
"; ModuleID = 'binary-expression/greaterThanGreaterThanGreaterThan.ts'
source_filename = \\"binary-expression/greaterThanGreaterThanGreaterThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_greaterThanGreaterThanGreaterThan() {
entry:
  %numberValue = alloca double
  %intValue = alloca i32
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %lshr = lshr i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %lshr3 = lshr i32 %intValue2, 2
  ret void
}

declare i32 @toInt32d(double)
"
`;

exports[`BinaryExpression lessThan 1`] = `
"; ModuleID = 'binary-expression/lessThan.ts'
source_filename = \\"binary-expression/lessThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_lessThan() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpLT = icmp slt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpLT3 = fcmp olt double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpLT5 = icmp slt i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression lessThanEquals 1`] = `
"; ModuleID = 'binary-expression/lessThanEquals.ts'
source_filename = \\"binary-expression/lessThanEquals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_lessThanEquals() {
entry:
  %trueValue = alloca i1
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpLE = icmp sle i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpLE3 = fcmp ole double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpLE5 = icmp sle i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression lessThanLessThan 1`] = `
"; ModuleID = 'binary-expression/lessThanLessThan.ts'
source_filename = \\"binary-expression/lessThanLessThan.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_lessThanLessThan() {
entry:
  %numberValue = alloca double
  %intValue = alloca i32
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %shl = shl i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %shl3 = shl i32 %intValue2, 2
  ret void
}

declare i32 @toInt32d(double)
"
`;

exports[`BinaryExpression minus 1`] = `
"; ModuleID = 'binary-expression/minus.ts'
source_filename = \\"binary-expression/minus.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_minus() {
entry:
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %sub = sub i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %fsub = fsub double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %sub4 = sub i32 %two3, 2
  store i32 %sub4, i32* %two, align 4
  %twoDouble5 = load double, double* %twoDouble, align 8
  %fsub6 = fsub double %twoDouble5, 2.000000e+00
  store double %fsub6, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression percent 1`] = `
"; ModuleID = 'binary-expression/percent.ts'
source_filename = \\"binary-expression/percent.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_percent() {
entry:
  %sixDouble = alloca double
  %six = alloca i32
  store i32 6, i32* %six, align 4
  store double 6.000000e+00, double* %sixDouble, align 8
  %six1 = load i32, i32* %six, align 4
  %srem = srem i32 8, %six1
  %sixDouble2 = load double, double* %sixDouble, align 8
  %frem = frem double 8.000000e+00, %sixDouble2
  ret void
}
"
`;

exports[`BinaryExpression plus 1`] = `
"; ModuleID = 'binary-expression/plus.ts'
source_filename = \\"binary-expression/plus.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_plus() {
entry:
  %twoDouble = alloca double
  %two = alloca i32
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %add = add i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %fadd = fadd double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %add4 = add i32 %two3, 2
  store i32 %add4, i32* %two, align 4
  %twoDouble5 = load double, double* %twoDouble, align 8
  %fadd6 = fadd double %twoDouble5, 2.000000e+00
  store double %fadd6, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression slash 1`] = `
"; ModuleID = 'binary-expression/slash.ts'
source_filename = \\"binary-expression/slash.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant { { [5 x i8]* }* } { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant { { [5 x i8]* }* }* @Math_object

define void @_slash() {
entry:
  %doubleProduct = alloca double
  %intProduct = alloca i32
  store i32 1, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %sdiv = sdiv i32 %intProduct1, 2
  store i32 %sdiv, i32* %intProduct, align 4
  store double 0x3FF5555555555555, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %div = fdiv double %doubleProduct2, 1.500000e+00
  store double %div, double* %doubleProduct, align 8
  ret void
}
"
`;
