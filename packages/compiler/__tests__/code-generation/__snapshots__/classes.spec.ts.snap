// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Classes array-with-objects-literal 1`] = `
"; ModuleID = 'classes/array-with-objects-literal.ts'
source_filename = \\"classes/array-with-objects-literal.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.Point = type { double, double }
%class.Array = type { i8**, i32, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@Point_name = private unnamed_addr constant [6 x i8] c\\"Point\\\\00\\"
@Point_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Point_name }

define double @_arrayWithObjectLiterals() {
entry:
  %items = alloca [3 x %class.Point*], align 4
  %array = alloca %class.Array*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.Point* @\\"classes/array-with-objects-literal.ts$Point$11constructordd\\"(double 1.000000e+00, double 2.000000e+00)
  %constructorReturnValue1 = call dereferenceable(16) %class.Point* @\\"classes/array-with-objects-literal.ts$Point$11constructordd\\"(double 3.000000e+00, double 4.000000e+00)
  %constructorReturnValue2 = call dereferenceable(16) %class.Point* @\\"classes/array-with-objects-literal.ts$Point$11constructordd\\"(double 5.000000e+00, double 6.000000e+00)
  %items3 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 0
  %0 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 0
  store %class.Point* %constructorReturnValue, %class.Point** %0, align 4
  %1 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 1
  store %class.Point* %constructorReturnValue1, %class.Point** %1, align 4
  %2 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 2
  store %class.Point* %constructorReturnValue2, %class.Point** %2, align 4
  %constructorReturnValue4 = call dereferenceable(12) %class.Array* @ArrayIPv_constructorPPvu(%class.Point** %items3, i32 3)
  store %class.Array* %constructorReturnValue4, %class.Array** %array, align 4
  %array5 = load %class.Array*, %class.Array** %array, align 4
  %\\"[i]\\" = call %class.Point* @ArrayIPv_geti(%class.Array* %array5, i32 0)
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %\\"[i]\\", i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  store double %x, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return6 = load double, double* %return, align 8
  ret double %return6
}

define linkonce_odr %class.Point* @\\"classes/array-with-objects-literal.ts$Point$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.Point*
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr1 = load double, double* %x.addr, align 8
  %\\"&x2\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double %x.addr1, double* %\\"&x2\\", align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %\\"&y4\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double %y.addr3, double* %\\"&y4\\", align 8
  ret %class.Point* %this
}

declare i8* @malloc(i32)

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIPv_constructorPPvu(%class.Point**, i32) #0

; Function Attrs: alwaysinline norecurse nounwind readonly
declare %class.Point* @ArrayIPv_geti(%class.Array* nocapture dereferenceable(12), i32) #1

; Function Attrs: alwaysinline
declare void @ArrayIPv_setiPv(%class.Array* nocapture dereferenceable(12), i32, %class.Point*) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { alwaysinline norecurse nounwind readonly }
"
`;

exports[`Classes class-only-with-attributes 1`] = `
"; ModuleID = 'classes/class-only-with-attributes.ts'
source_filename = \\"classes/class-only-with-attributes.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.ClassOnlyWithAttributes = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@ClassOnlyWithAttributes_name = private unnamed_addr constant [24 x i8] c\\"ClassOnlyWithAttributes\\\\00\\"
@ClassOnlyWithAttributes_type_descriptor = private constant { [24 x i8]* } { [24 x i8]* @ClassOnlyWithAttributes_name }

define double @_classOnlyWithAttributes() {
entry:
  %instance = alloca %class.ClassOnlyWithAttributes*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassOnlyWithAttributes* @\\"classes/class-only-with-attributes.ts$ClassOnlyWithAttributes$11constructor\\"()
  store %class.ClassOnlyWithAttributes* %constructorReturnValue, %class.ClassOnlyWithAttributes** %instance, align 4
  %instance1 = load %class.ClassOnlyWithAttributes*, %class.ClassOnlyWithAttributes** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassOnlyWithAttributes*, %class.ClassOnlyWithAttributes** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassOnlyWithAttributes* @\\"classes/class-only-with-attributes.ts$ClassOnlyWithAttributes$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassOnlyWithAttributes*
  %\\"&x\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  ret %class.ClassOnlyWithAttributes* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-only-with-methods 1`] = `
"; ModuleID = 'classes/class-only-with-methods.ts'
source_filename = \\"classes/class-only-with-methods.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.ClassOnlyWithMethods = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@ClassOnlyWithMethods_name = private unnamed_addr constant [21 x i8] c\\"ClassOnlyWithMethods\\\\00\\"
@ClassOnlyWithMethods_type_descriptor = private constant { [21 x i8]* } { [21 x i8]* @ClassOnlyWithMethods_name }

define double @_classOnlyWithMethods(double %x, double %y) {
entry:
  %instance = alloca %class.ClassOnlyWithMethods*, align 4
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %return = alloca double, align 8
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %constructorReturnValue = call dereferenceable(1) %class.ClassOnlyWithMethods* @\\"classes/class-only-with-methods.ts$ClassOnlyWithMethods$11constructor\\"()
  store %class.ClassOnlyWithMethods* %constructorReturnValue, %class.ClassOnlyWithMethods** %instance, align 4
  %x.addr1 = load double, double* %x.addr, align 8
  %y.addr2 = load double, double* %y.addr, align 8
  %instance3 = load %class.ClassOnlyWithMethods*, %class.ClassOnlyWithMethods** %instance, align 4
  %addReturnValue = call double @\\"classes/class-only-with-methods.ts$ClassOnlyWithMethods$3adddd\\"(%class.ClassOnlyWithMethods* %instance3, double %x.addr1, double %y.addr2)
  store double %addReturnValue, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return4 = load double, double* %return, align 8
  ret double %return4
}

define linkonce_odr %class.ClassOnlyWithMethods* @\\"classes/class-only-with-methods.ts$ClassOnlyWithMethods$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassOnlyWithMethods*
  ret %class.ClassOnlyWithMethods* %this
}

declare i8* @malloc(i32)

define linkonce_odr hidden double @\\"classes/class-only-with-methods.ts$ClassOnlyWithMethods$3adddd\\"(%class.ClassOnlyWithMethods* readonly dereferenceable(1) %this1, double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %this = alloca %class.ClassOnlyWithMethods*, align 4
  %return = alloca double, align 8
  store %class.ClassOnlyWithMethods* %this1, %class.ClassOnlyWithMethods** %this, align 4
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr2 = load double, double* %x.addr, align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %fadd = fadd double %x.addr2, %y.addr3
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return4 = load double, double* %return, align 8
  ret double %return4
}

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-access-to-constructor-defined-fields 1`] = `
"; ModuleID = 'classes/class-with-access-to-constructor-defined-fields.ts'
source_filename = \\"classes/class-with-access-to-constructor-defined-fields.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.ClassWithAttributeInitializer = type { double, double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithAttributeInitializer_name = private unnamed_addr constant [30 x i8] c\\"ClassWithAttributeInitializer\\\\00\\"
@ClassWithAttributeInitializer_type_descriptor = private constant { [30 x i8]* } { [30 x i8]* @ClassWithAttributeInitializer_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithAttributeInitializer*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(24) %class.ClassWithAttributeInitializer* @\\"classes/class-with-access-to-constructor-defined-fields.ts$ClassWithAttributeInitializer$11constructordd\\"(double 1.000000e+01, double 1.500000e+01)
  store %class.ClassWithAttributeInitializer* %constructorReturnValue, %class.ClassWithAttributeInitializer** %instance, align 4
  %instance1 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance1, i32 0, i32 1
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance2, i32 0, i32 2
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithAttributeInitializer* @\\"classes/class-with-access-to-constructor-defined-fields.ts$ClassWithAttributeInitializer$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 24)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithAttributeInitializer*
  %\\"&distance\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&distance\\"
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 2
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  %\\"&x1\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double %x, double* %\\"&x1\\", align 8
  store double %y, double* %y.addr, align 8
  %\\"&y2\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 2
  store double %y, double* %\\"&y2\\", align 8
  %\\"&x3\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  %x4 = load double, double* %\\"&x3\\", align 8
  %powReturnValue = call double @llvm.pow.f64(double %x4, double 2.000000e+00)
  %\\"&y5\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 2
  %y6 = load double, double* %\\"&y5\\", align 8
  %powReturnValue7 = call double @llvm.pow.f64(double %y6, double 2.000000e+00)
  %fadd = fadd double %powReturnValue, %powReturnValue7
  %sqrtReturnValue = call double @llvm.sqrt.f64(double %fadd)
  %\\"&distance8\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double %sqrtReturnValue, double* %\\"&distance8\\", align 8
  ret %class.ClassWithAttributeInitializer* %this
}

declare i8* @malloc(i32)

; Function Attrs: nounwind readnone
declare double @llvm.sqrt.f64(double) #0

; Function Attrs: nounwind readnone
declare double @llvm.pow.f64(double, double) #0

declare void @speedyJsGc()

attributes #0 = { nounwind readnone }
"
`;

exports[`Classes class-with-attribute-defined-in-constructor 1`] = `
"; ModuleID = 'classes/class-with-attribute-defined-in-constructor.ts'
source_filename = \\"classes/class-with-attribute-defined-in-constructor.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.ClassWithAttributeInitializer = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithAttributeInitializer_name = private unnamed_addr constant [30 x i8] c\\"ClassWithAttributeInitializer\\\\00\\"
@ClassWithAttributeInitializer_type_descriptor = private constant { [30 x i8]* } { [30 x i8]* @ClassWithAttributeInitializer_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithAttributeInitializer*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassWithAttributeInitializer* @\\"classes/class-with-attribute-defined-in-constructor.ts$ClassWithAttributeInitializer$11constructordd\\"(double 1.000000e+01, double 1.500000e+01)
  store %class.ClassWithAttributeInitializer* %constructorReturnValue, %class.ClassWithAttributeInitializer** %instance, align 4
  %instance1 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithAttributeInitializer* @\\"classes/class-with-attribute-defined-in-constructor.ts$ClassWithAttributeInitializer$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithAttributeInitializer*
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  %\\"&x1\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double %x, double* %\\"&x1\\", align 8
  store double %y, double* %y.addr, align 8
  %\\"&y2\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double %y, double* %\\"&y2\\", align 8
  ret %class.ClassWithAttributeInitializer* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-attribute-initializer 1`] = `
"; ModuleID = 'classes/class-with-attribute-initializer.ts'
source_filename = \\"classes/class-with-attribute-initializer.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.ClassWithAttributeInitializer = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithAttributeInitializer_name = private unnamed_addr constant [30 x i8] c\\"ClassWithAttributeInitializer\\\\00\\"
@ClassWithAttributeInitializer_type_descriptor = private constant { [30 x i8]* } { [30 x i8]* @ClassWithAttributeInitializer_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithAttributeInitializer*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassWithAttributeInitializer* @\\"classes/class-with-attribute-initializer.ts$ClassWithAttributeInitializer$11constructor\\"()
  store %class.ClassWithAttributeInitializer* %constructorReturnValue, %class.ClassWithAttributeInitializer** %instance, align 4
  %instance1 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithAttributeInitializer* @\\"classes/class-with-attribute-initializer.ts$ClassWithAttributeInitializer$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithAttributeInitializer*
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double 1.000000e+01, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  ret %class.ClassWithAttributeInitializer* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-constructor 1`] = `
"; ModuleID = 'classes/class-with-constructor.ts'
source_filename = \\"classes/class-with-constructor.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.ClassWithConstructor = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithConstructor_name = private unnamed_addr constant [21 x i8] c\\"ClassWithConstructor\\\\00\\"
@ClassWithConstructor_type_descriptor = private constant { [21 x i8]* } { [21 x i8]* @ClassWithConstructor_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithConstructor*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassWithConstructor* @\\"classes/class-with-constructor.ts$ClassWithConstructor$11constructordd\\"(double 1.000000e+01, double 2.000000e+01)
  store %class.ClassWithConstructor* %constructorReturnValue, %class.ClassWithConstructor** %instance, align 4
  %instance1 = load %class.ClassWithConstructor*, %class.ClassWithConstructor** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithConstructor*, %class.ClassWithConstructor** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithConstructor* @\\"classes/class-with-constructor.ts$ClassWithConstructor$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithConstructor*
  %\\"&x\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr1 = load double, double* %x.addr, align 8
  %\\"&x2\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 0
  store double %x.addr1, double* %\\"&x2\\", align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %\\"&y4\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 1
  store double %y.addr3, double* %\\"&y4\\", align 8
  ret %class.ClassWithConstructor* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-methods 1`] = `
"; ModuleID = 'classes/class-with-methods.ts'
source_filename = \\"classes/class-with-methods.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { { [5 x i8]* }* }
%class.Point = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math { { [5 x i8]* }* @Math_type_descriptor }
@Math_ptr = private constant %class.Math* @Math_object
@Point_name = private unnamed_addr constant [6 x i8] c\\"Point\\\\00\\"
@Point_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Point_name }

define void @_classWithMethods(double %x, double %y) {
entry:
  %other = alloca %class.Point*, align 4
  %center = alloca %class.Point*, align 4
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %constructorReturnValue = call dereferenceable(16) %class.Point* @\\"classes/class-with-methods.ts$Point$11constructordd\\"(double 0.000000e+00, double 0.000000e+00)
  store %class.Point* %constructorReturnValue, %class.Point** %center, align 4
  %x.addr1 = load double, double* %x.addr, align 8
  %y.addr2 = load double, double* %y.addr, align 8
  %constructorReturnValue3 = call dereferenceable(16) %class.Point* @\\"classes/class-with-methods.ts$Point$11constructordd\\"(double %x.addr1, double %y.addr2)
  store %class.Point* %constructorReturnValue3, %class.Point** %other, align 4
  %other4 = load %class.Point*, %class.Point** %other, align 4
  %center5 = load %class.Point*, %class.Point** %center, align 4
  %distanceToReturnValue = call double @\\"classes/class-with-methods.ts$Point$10distanceTo5PointI\\"(%class.Point* %center5, %class.Point* %other4)
  ret void
}

define linkonce_odr %class.Point* @\\"classes/class-with-methods.ts$Point$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.Point*
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr1 = load double, double* %x.addr, align 8
  %\\"&x2\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double %x.addr1, double* %\\"&x2\\", align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %\\"&y4\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double %y.addr3, double* %\\"&y4\\", align 8
  ret %class.Point* %this
}

declare i8* @malloc(i32)

define linkonce_odr hidden double @\\"classes/class-with-methods.ts$Point$10distanceTo5PointI\\"(%class.Point* readonly dereferenceable(16) %this1, %class.Point* dereferenceable(16) %to) {
entry:
  %to.addr = alloca %class.Point*, align 4
  %this = alloca %class.Point*, align 4
  %return = alloca double, align 8
  store %class.Point* %this1, %class.Point** %this, align 4
  store %class.Point* %to, %class.Point** %to.addr, align 4
  %this2 = load %class.Point*, %class.Point** %this, align 4
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %this2, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %to.addr3 = load %class.Point*, %class.Point** %to.addr, align 4
  %\\"&x4\\" = getelementptr inbounds %class.Point, %class.Point* %to.addr3, i32 0, i32 0
  %x5 = load double, double* %\\"&x4\\", align 8
  %fsub = fsub double %x, %x5
  %powReturnValue = call double @llvm.pow.f64(double %fsub, double 2.000000e+00)
  %this6 = load %class.Point*, %class.Point** %this, align 4
  %\\"&y\\" = getelementptr inbounds %class.Point, %class.Point* %this6, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %to.addr7 = load %class.Point*, %class.Point** %to.addr, align 4
  %\\"&y8\\" = getelementptr inbounds %class.Point, %class.Point* %to.addr7, i32 0, i32 1
  %y9 = load double, double* %\\"&y8\\", align 8
  %fsub10 = fsub double %y, %y9
  %powReturnValue11 = call double @llvm.pow.f64(double %fsub10, double 2.000000e+00)
  %fadd = fadd double %powReturnValue, %powReturnValue11
  %sqrtReturnValue = call double @llvm.sqrt.f64(double %fadd)
  store double %sqrtReturnValue, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return12 = load double, double* %return, align 8
  ret double %return12
}

; Function Attrs: nounwind readnone
declare double @llvm.sqrt.f64(double) #0

; Function Attrs: nounwind readnone
declare double @llvm.pow.f64(double, double) #0

declare void @speedyJsGc()

attributes #0 = { nounwind readnone }
"
`;
