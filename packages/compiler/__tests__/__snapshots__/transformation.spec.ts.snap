// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Transformation casts the return value for boolean functions to a bool value 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./istruthy.wasm\\", {
    totalStack: 532480,
    initialMemory: 16777216,
    globalBase: 8,
    staticBump: 8,
    exposeGc: false
});
function isTruthy(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._isTruthy(value) === 1; loadWasmModule_1.gc(); return result; }); }
"
`;

exports[`Transformation does not rewrite source files without any speedyjs functions 1`] = `
"function isPrime(value) {
    if (value <= 2) {
        return false;
    }
    for (let i = 2; i <= (Math.sqrt(value) | 0); ++i) {
        if (value % i === 0) {
            return false;
        }
    }
    return true;
}
"
`;

exports[`Transformation emits a diagnostic if a non entry speedyjs function is referenced from normal JavaScriptCode 1`] = `
"test.ts(8,20): error TS100010: SpeedyJS functions referenced from 'normal' JavaScript code needs to be async (the async modifier is missing on the declaration of 'nonEntryFunction').
"
`;

exports[`Transformation emits a diagnostic if the entry function has optional parameters 1`] = `
"test.ts(2,51): error TS100011: Optional parameters or variadic parameters are not supported for SpeedyJS entry functions
"
`;

exports[`Transformation emits a diagnostic if the entry function is generic 1`] = `
"test.ts(1,1): error TS100012: Generic SpeedyJS entry functions are not supported
"
`;

exports[`Transformation emits a diagnostic if the entry function is overloaded 1`] = `
"test.ts(3,67): error TS100013: SpeedyJS entry function cannot be overloaded
"
`;

exports[`Transformation exports the gc function if exportGc is set 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", {
    totalStack: 532480,
    initialMemory: 16777216,
    globalBase: 8,
    staticBump: 8,
    exposeGc: true
});
export const speedyJsGc = loadWasmModule_1.gc;
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._fib(value); loadWasmModule_1.gc(); return result; }); }
"
`;

exports[`Transformation exposes the gc function if exposeGc is set 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", {
    totalStack: 532480,
    initialMemory: 16777216,
    globalBase: 8,
    staticBump: 8,
    exposeGc: true
});
const speedyJsGc = loadWasmModule_1.gc;
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._fib(value); loadWasmModule_1.gc(); return result; }); }
"
`;

exports[`Transformation passes the configured global base to the module loader 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", {
    totalStack: 532480,
    initialMemory: 16777216,
    globalBase: 4000,
    staticBump: 8,
    exposeGc: false
});
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._fib(value); loadWasmModule_1.gc(); return result; }); }
"
`;

exports[`Transformation passes the configured initial memory to the module loader 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", {
    totalStack: 532480,
    initialMemory: 10485760,
    globalBase: 8,
    staticBump: 8,
    exposeGc: false
});
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._fib(value); loadWasmModule_1.gc(); return result; }); }
"
`;

exports[`Transformation passes the configured total stack to the module loader 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", {
    totalStack: 1048576,
    initialMemory: 16777216,
    globalBase: 8,
    staticBump: 8,
    exposeGc: false
});
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._fib(value); loadWasmModule_1.gc(); return result; }); }
"
`;

exports[`Transformation rewrites the speedyjs function to call into the web assembly module 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * Part of this source code has been taken from https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
var Allocation;
(function (Allocation) {
    /**
     * Tries to use _malloc()
     */
    Allocation[Allocation[\\"NORMAL\\"] = 0] = \\"NORMAL\\";
    /**
     * Lives for the duration of the current function call
     */
    Allocation[Allocation[\\"STACK\\"] = 1] = \\"STACK\\";
    /**
     * Cannot be freed
     */
    Allocation[Allocation[\\"STATIC\\"] = 2] = \\"STATIC\\";
    /**
     * Cannot be freed except through sbrk
     */
    Allocation[Allocation[\\"DYNAMIC\\"] = 3] = \\"DYNAMIC\\";
    /**
     * Do not allocate
     */
    Allocation[Allocation[\\"NONE\\"] = 4] = \\"NONE\\";
})(Allocation || (Allocation = {}));
function __moduleLoader(wasmUri, options) {
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    var HEAP32 = new Int32Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    HEAP32[GLOBAL_BASE >> 2] = STACK_TOP;
    // where does the dynamic heap memory start
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    HEAP32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = HEAP32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        HEAP32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            HEAP32 = new Int32Array(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== 'undefined' && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module[\\"require\\"];
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    \\"__cxa_allocate_exception\\": function () {
                        console.log(\\"__cxa_allocate_exception\\", arguments);
                    },
                    \\"__cxa_throw\\": function () {
                        console.log(\\"__cxa_throw\\", arguments);
                    },
                    \\"__cxa_find_matching_catch_2\\": function () {
                        console.log(\\"__cxa_find_matching_catch_2\\", arguments);
                    },
                    \\"__cxa_free_exception\\": function () {
                        console.log(\\"__cxa_free_exception\\", arguments);
                    },
                    \\"__resumeException\\": function () {
                        console.log(\\"__resumeException\\", arguments);
                    },
                    \\"__cxa_atexit\\": function () {
                        console.log(\\"__cxa_atexit\\", arguments);
                    },
                    \\"pow\\": Math.pow,
                    \\"fmod\\": function frem(x, y) {
                        return x % y;
                    },
                    \\"abort\\": function (what) {
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    \\"invoke_ii\\": function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    \\"invoke_iii\\": function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    \\"invoke_iiii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    \\"invoke_iiiii\\": function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    \\"invoke_viii\\": function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    \\"sbrk\\": sbrk
                }
            });
        }).then(function (result) { return instance = result.instance; });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded = undefined;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
const loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", {
    totalStack: 532480,
    initialMemory: 16777216,
    globalBase: 8,
    staticBump: 8,
    exposeGc: false
});
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance) { var result = instance.exports._fib(value); loadWasmModule_1.gc(); return result; }); }
"
`;
